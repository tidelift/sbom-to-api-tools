package main

//go:generate oapi-codegen --package=tidelift_api_gen -generate=types -include-tags Packages,Releases,Vulnerabilities -o ../../internal/tidelift-api-gen/tidelift.gen.go https://tidelift.com/api/depci/subscriber-api.json

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"os"

	requests "github.com/carlmjohnson/requests"
	"github.com/package-url/packageurl-go"
	log "github.com/sirupsen/logrus"
	cyclonedx "github.com/tidelift/tidelift-sbom-info/internal/cyclonedx"
	api "github.com/tidelift/tidelift-sbom-info/internal/tidelift-api-gen"
	utils "github.com/tidelift/tidelift-sbom-info/internal/utils"
)

type RecommendationDetails struct {
	RealIssue             bool    `json:"real_issue"`
	FalsePositiveReason   *string `json:"false_positive_reason"`
	ImpactScore           *int    `json:"impact_score"`
	ImpactDescription     *string `json:"impact_description"`
	WorkaroundAvailable   *bool   `json:"workaround_available"`
	WorkaroundDescription *string `json:"workaround_description"`
}

type VulnerabilityDetails struct {
	VulnerabilityId       string                 `json:"vulnerability_id"`
	NistUrl               string                 `json:"nist_url"`
	CvssScore             string                 `json:"cvss_score"`
	Platform              string                 `json:"platform"`
	Name                  string                 `json:"name"`
	Version               string                 `json:"version"`
	Purl                  string                 `json:"purl"`
	Recommendation        string                 `json:"recommendation"`
	RecommendationDetails *RecommendationDetails `json:"recommendation_details"`
}

// This gets overwritten by goreleaser with the git tag, during a release.
var (
	version = "dev"
)

func main() {
	var debug bool
	var outputFile string
	var printVersion bool

	flag.BoolVar(&debug, "debug", false, "Show debug logging")
	flag.StringVar(&outputFile, "output", "", "Write output to a file (defaults to stdout)")
	flag.BoolVar(&printVersion, "version", false, "Show version information")

	flag.Usage = func() {
		fmt.Fprintln(flag.CommandLine.Output(), "Display a JSON file containing vulnerabilities from Tidelift for the packages in an SBOM.")
		fmt.Fprintln(flag.CommandLine.Output(), "")
		fmt.Fprintln(flag.CommandLine.Output(), "Usage:")
		fmt.Fprintln(flag.CommandLine.Output(), "  tidelift-sbom-vulnerability-reporter [SOURCE]")
		fmt.Fprintln(flag.CommandLine.Output(), "")
		fmt.Fprintln(flag.CommandLine.Output(), "Flags:")
		flag.PrintDefaults()
	}

	flag.Parse()

	if printVersion {
		fmt.Println(version)
		os.Exit(0)
	}

	if _, keyExists := os.LookupEnv("TIDELIFT_API_KEY"); !keyExists {
		log.Fatalf("Error: TIDELIFT_API_KEY environment variable is required.")
	}

	if flag.NArg() != 1 {
		fmt.Fprintln(os.Stderr, "Error: need to pass cyclonedx file as argument")
		flag.Usage()
		os.Exit(1)
	}

	if debug {
		log.SetLevel(log.DebugLevel)
	} else {
		log.SetLevel(log.WarnLevel)
	}

	_, purls, err := cyclonedx.SupportedPurlsFromBomFile(flag.Arg(0))
	if err != nil {
		log.Fatalf("Error: %s", err)
	}

	releaseInfo, missingReleases := utils.GetReleaseInfo(purls)

	if len(missingReleases) > 0 {
		log.Debug(fmt.Sprintf("Unable to look up %d releases (may be internal packages)", len(missingReleases)))
	}

	if err := writeVulnerabilitiesReport(outputFile, purls, releaseInfo); err != nil {
		log.Fatalf("Error: %s", err)
	}
}

func writeVulnerabilitiesReport(outputFile string, purls []packageurl.PackageURL, releaseInfo []api.ReleaseDetail) error {
	vulnerabilties := []VulnerabilityDetails{}

	for _, purl := range purls {
		releasePurlString := purl.ToString()
		pkgPurlString := utils.ReleasePurlToPackagePurl(purl).String()
		for _, r := range releaseInfo {
			if *r.Purl == releasePurlString {
				if len(*r.Violations) == 0 {
					break
				}
				for _, violation := range *r.Violations {
					if *violation.CatalogStandard == "vulnerabilities" {
						// oapi spec doesn't give definition of the additional properties but this is how vuln ids come through
						id, ok := violation.AdditionalProperties["vulnerability"].(map[string]interface{})["id"].(string)
						if !ok {
							jsonStr, err := json.MarshalIndent(violation, "", " ")
							if err != nil {
								return err
							}
							log.Warn(fmt.Sprintf("Unable to parse vulnerability info: %s", jsonStr))
							continue
						}
						var vulnRsp api.Vulnerability
						log.Debug(fmt.Sprintf("Getting vulnerability info for %s", id))
						if err := requests.URL(fmt.Sprintf("https://api.tidelift.com/external-api/v1/vulnerabilities/%s", id)).
							ToJSON(&vulnRsp).
							ContentType("application/json").
							// TODO: could use the full auth setup that we do in the tidelift cli
							Header("Authorization", "Bearer "+os.Getenv("TIDELIFT_API_KEY")).
							Header("User-Agent", "tidelift-sbom-info/0.1").
							Fetch(context.Background()); err != nil {
							log.Warn(fmt.Sprintf("problem fetching vulnerability info %s ", err))
							continue
						}
						for _, a := range vulnRsp.AffectedPackages {
							if a.Purl == pkgPurlString {
								v := VulnerabilityDetails{
									VulnerabilityId: id,
									NistUrl:         *vulnRsp.NistUrl,
									Platform:        *r.Platform,
									Name:            *r.Name,
									Version:         *r.Version,
									Purl:            *r.Purl,
									Recommendation:  string(a.Recommendation),
								}

								if vulnRsp.CvssScore != nil {
									v.CvssScore = *vulnRsp.CvssScore
								}

								if a.RecommendationDetails != nil {
									r := RecommendationDetails{
										RealIssue:             a.RecommendationDetails.RealIssue,
										FalsePositiveReason:   a.RecommendationDetails.FalsePositiveReason,
										ImpactScore:           a.RecommendationDetails.ImpactScore,
										ImpactDescription:     a.RecommendationDetails.ImpactDescription,
										WorkaroundAvailable:   a.RecommendationDetails.WorkaroundAvailable,
										WorkaroundDescription: a.RecommendationDetails.WorkaroundDescription,
									}
									v.RecommendationDetails = &r
								}
								vulnerabilties = append(vulnerabilties, v)
								break
							}
						}
					}
				}
			}
		}
	}

	if outputFile != "" {
		f, err := os.Create(outputFile)
		if err != nil {
			return err
		}
		jsonStr, err := json.Marshal(vulnerabilties)
		if err != nil {
			return err
		}
		_, err = f.Write(jsonStr)
		if err != nil {
			return err
		}
		f.Close()
	} else {
		jsonStr, err := json.MarshalIndent(vulnerabilties, "", "  ")
		if err != nil {
			return err
		}
		fmt.Print(string(jsonStr))
	}

	return nil
}
